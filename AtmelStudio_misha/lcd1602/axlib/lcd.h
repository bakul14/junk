
//--------------------------------------<                        axlib v1.1                             >-------------------------------------------
//--------------------------------------< Библиотека для управления знакосинтезирующим ЖК дисплеем 16x2 >-------------------------------------------
//--------------------------------------<          Кузнецов Алексей 2015 http://www.avrki.ru            >-------------------------------------------


#ifndef LCD_H_
#define LCD_H_

#if !defined(MAIN_INIT_H_)
#error "You must included (#include \"main_init.h\") befor use (#include <axlib/lcd.h>)."
#endif

#include <avr/io.h>
#include <util/delay.h>

#if defined(R74HC595_LCD)
	#include <axlib/74hc595.h>
#endif

#include <axlib/type_var.h>

#if defined(RUS_FONT)		// Директива для подключения русского языка в китайских дисплеях
	#include <axlib/font.h>
#endif



//-------------------------------------------------------------------------
//	Объявление команд
//-------------------------------------------------------------------------

// Работа с дисплеем на прямую

#if !defined(R74HC595_LCD)
	#define E_SET()		(PORT_E |= (1 << E))		// Е в единицу
	#define E_RESET()	(PORT_E &= ~(1 << E))		// Е в ноль
	#define RS_COM()	(PORT_RS &= ~(1 << RS))		// Запись команды
	#define RS_DATA()	(PORT_RS |= (1 << RS))		// Запись данных

// Работа с дисплеем через сдвиговый регистр 74HC595
#else
	#define E_SET(data)		(data |= (1 << 3))		// Е в единицу
	#define E_RESET(data)	(data &= ~(1 << 3))		// Е в ноль
	#define RS_COM(data)	(data &= ~(1 << 2))	// Запись команды
	#define RS_DATA(data)	(data |= (1 << 2))		// Запись данных
#endif

//-------------------------------------------------------------------------
//	Функция разбора и вывода полубайта по пинам
//	Получаемый аргумент:
//			BYTE data
//			Полубайт требуемый вывода
//-------------------------------------------------------------------------

void lcd_out(BYTE data)
{
// Работа с дисплеем на прямую

#if !defined(R74HC595_LCD)

	if(data & 0x01)
	{
		PORT_D4 |= (1 << D4);
	}
	else
	{
		PORT_D4 &= ~(1 << D4);
	}
	if(data & 0x02)
	{
		PORT_D5 |= (1 << D5);
	}
	else
	{
		PORT_D5 &= ~(1 << D5);
	}
	if(data & 0x04)
	{
		PORT_D6 |= (1 << D6);
	}
	else
	{
		PORT_D6 &= ~(1 << D6);
	}
	if(data & 0x08)
	{
		PORT_D7 |= (1 << D7);
	}
	else
	{
		PORT_D7 &= ~(1 << D7);
	}
	
// Работа с дисплеем через сдвиговый регистр 74HC595
#else
	
	reg_74hc595_byte(data);

#endif
}

//-------------------------------------------------------------------------
//	Функция передачи команды в дисплей
//	Получаемый аргумент:
//			BYTE com
//			Команда
//-------------------------------------------------------------------------

void lcd_com(BYTE com)
{	
// Работа с дисплеем на прямую

#if !defined(R74HC595_LCD)

	RS_COM();				// Вывод команды
	lcd_out(com);			// Вывод данных на пины
	E_SET();				// Выставить Е
	E_RESET();				// Сбросить Е
	_delay_ms(4);			// После команды пауза

// Работа с дисплеем через сдвиговый регистр 74HC595
#else

	RS_COM(com);						// Запись команды
	reg_74hc595_byte(E_SET(com));		// Выставить Е
	reg_74hc595_byte(E_RESET(com));		// Сбросить Е
	_delay_ms(4);						// После команды пауза
	
#endif

}

//-------------------------------------------------------------------------
//	Функция инициализации дисплея
//	Получаемые аргументы:
//			BYTE lcd
//			0 - Позиция левый верхний угол, курсор не выводится
//			1 - Позиция левый верхний угол, курсор мигает в виде всего символа
//			2 - Позиция левый верхний угол, курсор в виде подчеркивания
//			3 - Позиция левый верхний угол, курсор в виде подчеркивания и мигает символ
//-------------------------------------------------------------------------
void lcd_init(BYTE lcd)
{
// Работа с дисплеем на прямую

#if !defined(R74HC595_LCD)

	DDR_RS |= (1 << RS);
	DDR_E  |= (1 << E);
	DDR_D4 |= (1 << D4);
	DDR_D5 |= (1 << D5);
	DDR_D6 |= (1 << D6);
	DDR_D7 |= (1 << D7);
	
	switch (lcd)
	{
		case 0: lcd = 0x0C; break;
		case 1: lcd = 0x0D; break;
		case 2: lcd = 0x0E; break;
		case 3: lcd = 0x0F; break;
	}
	
	_delay_ms(20);		// После включения питания подождать 20 мс
	
	lcd_com(0x03);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x03);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x03);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x02);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x02);		// Установка параметров
	lcd_com(0x08);		// Установка параметров
	lcd_com(0x00);		// Выключаем дисплей
	lcd_com(0x08);		// Выключаем дисплей
	lcd_com(0x00);		// Очищаем дисплей
	lcd_com(0x01);		// Очищаем дисплей
	lcd_com(0x00);		// Устанавливаем режим ввода данных
	lcd_com(0x06);		// Устанавливаем режим ввода данных
	lcd_com(0x00);		// Включаем дисплей с выбранным курсором
	lcd_com(lcd);		// Включаем дисплей с выбранным курсором

// Работа с дисплеем через сдвиговый регистр 74HC595	
#else
	
	reg_74hc595_init();
	
	switch (lcd)
	{
		case 0: lcd = 0xC0; break;
		case 1: lcd = 0xD0; break;
		case 2: lcd = 0xE0; break;
		case 3: lcd = 0xF0; break;
	}
	
	_delay_ms(20);		// После включения питания подождать 20 мс
	
	lcd_com(0x30);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x30);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x30);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x20);		// Переход в 4-х битный режим
	_delay_us(40);
	lcd_com(0x20);		// Установка параметров
	lcd_com(0x80);		// Установка параметров
	lcd_com(0x00);		// Выключаем дисплей
	lcd_com(0x80);		// Выключаем дисплей
	lcd_com(0x00);		// Очищаем дисплей
	lcd_com(0x10);		// Очищаем дисплей
	lcd_com(0x00);		// Устанавливаем режим ввода данных
	lcd_com(0x60);		// Устанавливаем режим ввода данных
	lcd_com(0x00);		// Включаем дисплей с выбранным курсором
	lcd_com(lcd);		// Включаем дисплей с выбранным курсором
	
#endif
}

//-------------------------------------------------------------------------
//	Функция отправки байта данных дисплею
//	Принимаемый аргумент:
//			BYTE data
//			Передаваемый байт
//-------------------------------------------------------------------------
void lcd_char_out(BYTE data)
{
// Работа с дисплеем на прямую
#if !defined(R74HC595_LCD)

	RS_DATA();							// Передача данных
	
	lcd_out(data >> 4);					// Передача старших 4 бит
	E_SET();
	E_RESET();
	
	lcd_out(data & 0x0F);				// Передача младших 4 бит
	E_SET();
	E_RESET();
	
	_delay_ms(4);						// После командная пауза

// Работа с дисплеем через сдвиговый регистр 74HC595
#else

	BYTE temp = 0;
	temp = (data & 0xF0);				// Передача старших 4 бит
	RS_DATA(temp);						// Передача данных
	reg_74hc595_byte(E_SET(temp));		// Выставить Е
	reg_74hc595_byte(E_RESET(temp));	// Сбросить Е
	
	temp = (data << 4);					// Передача младших 4 бит
	RS_DATA(temp);						// Передача данных
	reg_74hc595_byte(E_SET(temp));		// Выставить Е
	reg_74hc595_byte(E_RESET(temp));	// Сбросить Е
	
	_delay_ms(2);						// После командная пауза
	
#endif

}

//-------------------------------------------------------------------------
//	Функция вывода строки
//	Принимаемый аргумент:
//			BYTE *str
//			Указатель на массив заканчивающийся нулевым символом.
//-------------------------------------------------------------------------
void lcd_str_out(BYTE *str)
{
	while((*str) != '\0')
	{
		lcd_char_out(*str);
		str++;
	}
}

//-------------------------------------------------------------------------
//	Функция переводит курсор по осям X, Y
//	Получаемые аргументы:
//			BYTE x, BYTE y
//			х - значение от 0 до 39. Длинна строки
//			y - значение от 0 до 3.  Номер строки
//-------------------------------------------------------------------------
void lcd_gotoxy(BYTE x, BYTE y)
{
	if(x > 39) x = 39;
	if(x < 0) x = 0;
	if(y > 3) y = 3;
	if(y < 0) y = 0;
	
	BYTE temp = 0x00;
	
// Работа с дисплеем на прямую

#if !defined(R74HC595_LCD)	
	RS_COM();
	
	switch (y)
	{
		case 0:
		{
			temp |= (0x80 + x);
			lcd_com(temp >> 4);			// Передача старших 4 бит
			lcd_com(temp & 0x0F);		// Передача младших 4 бит
			break;
		}
		case 1:
		{
			temp |= (0xC0 + x);
			lcd_com(temp >> 4);			// Передача старших 4 бит
			lcd_com(temp & 0x0F);		// Передача младших 4 бит
			break;
		}
		case 2:
		{
			temp |= (0x94 + x);
			lcd_com(temp >> 4);			// Передача старших 4 бит
			lcd_com(temp & 0x0F);		// Передача младших 4 бит
			break;
		}
		case 3:
		{
			temp |= (0xD4 + x);
			lcd_com(temp >> 4);			// Передача старших 4 бит
			lcd_com(temp & 0x0F);		// Передача младших 4 бит
			break;
		}
	}
#else
	RS_COM(temp);
	
	switch (y)
	{
		case 0:
		{
			temp |= (0x80 + x);
			lcd_com(temp & 0xF0);		// Передача младших 4 бит
			lcd_com(temp >> 4);			// Передача старших 4 бит
			break;
		}
		case 1:
		{
			temp |= (0xC0 + x);
			lcd_com(temp & 0xF0);		// Передача младших 4 бит
			lcd_com(temp >> 4);			// Передача старших 4 бит
			break;
		}
		case 2:
		{
			temp |= (0x94 + x);
			lcd_com(temp & 0xF0);		// Передача младших 4 бит
			lcd_com(temp >> 4);			// Передача старших 4 бит
			break;
		}
		case 3:
		{
			temp |= (0xD4 + x);
			lcd_com(temp & 0xF0);		// Передача младших 4 бит
			lcd_com(temp >> 4);			// Передача старших 4 бит
			break;
		}
	}
#endif
	
	
}

//-------------------------------------------------------------------------
//	Функция очистки дисплея и установки курсора на 0 строку, 0 символ
//-------------------------------------------------------------------------
void lcd_clear(void)
{
	lcd_com(0x00);
	lcd_com(0x01);
}

//-------------------------------------------------------------------------
//	Функция создания и записи в память своего символа
//	Передаваемые аргументы:
//		BYTE simbol - Адрес в CGRAM от 0 до 15
//		BYTE *str - Указатель на начало массива с байтами символа
//-------------------------------------------------------------------------
void lcd_simbol(BYTE simbol, BYTE *str) 
{
	simbol = (8 * simbol) | 0x40;
	
#if !defined(R74HC595_LCD)		
	
	lcd_com(simbol >> 4);
	lcd_com(simbol & 0x0F);
#else

	lcd_com(simbol & 0xF0);
	lcd_com(simbol >> 4);
#endif
	
	for(BYTE i = 0; i <= 7; i++)				
	{
		lcd_char_out(*str);
		str++;
	}
	
	lcd_gotoxy(0,0);

}


#if defined(RUS_FONT)	
//-------------------------------------------------------------------------
//	Функция создания и записи в память русской буквы
//	Передаваемые аргументы:
//		BYTE simbol - Адрес в CGRAM от 0 до 15
//		BYTE add - Адрес буквы в массиве lcd_font[add][x]
//
//-------------------------------------------------------------------------
void lcd_fsimbol(BYTE simbol, BYTE add, BYTE ves)
{
	BYTE byte = 0;
	simbol = (8 * simbol) | 0x40;
	
	lcd_com(simbol >> 4);
	lcd_com(simbol & 0x0F);
	
	for(BYTE i = 0; i <= 7; i++)
	{
		if(ves == 0) byte = pgm_read_byte(&(lcd_font_b[add][i]));
		if(ves == 1) byte = pgm_read_byte(&(lcd_font_s[add][i]));
		lcd_char_out(byte);
	}
	
	lcd_gotoxy(0,0);

}

//-------------------------------------------------------------------------
//	Функция вывода строки на ЖК дисплей
//	Передаваемые аргументы:
//		BYTE *str - Указатель на адрес строки с русскими буквами
//		BYTE x - Координата начала строки по X
//		BYTE y - Координата начала строки по Y
//
//-------------------------------------------------------------------------

void lcd_rus_out(BYTE *str, BYTE x, BYTE y)
{
	//BYTE ttt[20];
	
	BYTE rus_str[20];	// Максимальное количество символов 20
	BYTE i = 0;			// Счетчик адресов CGRAM
	BYTE temp = 0;		// Технический счетчик
	BYTE j = 0;			// Счетчик массива
	BYTE ram = 0;

	while(*str != 0x00)
	{
		if(((*str != 0xD0) & (*str != 0xD1)))
		{ // Если в байте отсутствует префикс русской буквы			
			if(*str > 0x7F)
				{ // Если русская буква	
					if((*str > 0x8F) & (*str < 0xB0))
						{ // Заглавная буква
							
							temp = 0;
							while(temp < 10) // Эквиваленты
								{									
									if(pgm_read_byte(&lcd_rus_eng_b[temp][0]) == *str) // Замена латинским эквивалентом
										{
											rus_str[j] = pgm_read_byte(&lcd_rus_eng_b[temp][1]);
										}
									temp++;
								} //--- Конец замены символа эквивалента
								
							temp = 0;	
							while(temp < 22)
								{
									if(pgm_read_byte(&lcd_rus_b[temp][0]) == *str) // Запись адреса CGRAM
										{
											lcd_fsimbol(ram, pgm_read_byte(&lcd_rus_b[temp][1]), 0);
											rus_str[j] = ram;										
											ram++;	
										}
									temp++;
								} //--- Конец записи адреса CGRAM
						}
					else
						{ // Прописная буква
							
							temp = 0;
							while(temp < 7) // Эквиваленты
								{
									if(pgm_read_byte(&lcd_rus_eng_s[temp][0]) == *str) // Замена латинским эквивалентом
										{
											rus_str[j] = pgm_read_byte(&lcd_rus_eng_s[temp][1]);
										}
									temp++;
								} //--- Конец замены символа эквивалента
								
							temp = 0;
							while(temp < 25)
								{
									if(pgm_read_byte(&lcd_rus_s[temp][0]) == *str) // Запись адреса CGRAM
										{
											lcd_fsimbol(ram, pgm_read_byte(&lcd_rus_s[temp][1]), 1);
											rus_str[j] = ram;
											ram++;
										}
									temp++;
								} //--- Конец записи адреса CGRAM	
						}
				}
			else
				{ // Если латинская или знак
					rus_str[j] = *str;
				}
				
			j++; // Увеличение длинны строки
			
			rus_str[j] = 0xFF; // Конец строки
		} // Конец проверки на D0 D1
		
		str++; // Следущий байт
		
	} // Конец основного while()
	
	// Вывод на дисплей
	
	temp = 0;
	j = 0;
	
	lcd_gotoxy(x,y);
	
	while(rus_str[temp] != 0xFF)
	{
		lcd_char_out(rus_str[temp]);
		temp++;
	}
	
}

#endif

#endif /* LCD_H_ */ 