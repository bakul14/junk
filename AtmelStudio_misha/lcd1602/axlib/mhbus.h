
//------------------------------------------------<                   axlib v1.1                      >----------------------------------------------------
//------------------------------------------------< Библиотека для работы с протоколом MH-BUS ведомый >----------------------------------------------------
//------------------------------------------------<    Кузнецов Алексей 2015 http://www.avrki.ru      >----------------------------------------------------

#ifndef MHBUS_SLAVE_H_
#define MHBUS_SLAVE_H_

#if !defined(MAIN_INIT_H_)
#error "You must included (#include \"main_init.h\") befor use (#include <axlib/mhbus_slave.h>)."
#endif

//-------------------------------------------------------------------------
//						Подключаемые библиотеки
//-------------------------------------------------------------------------

#include <avr/eeprom.h>
#include <axlib/type_var.h>
#include <axlib/usart.h>
#include <axlib/mhbus_const.h>

//-------------------------------------------------------------------------
//							Макроопределения
//-------------------------------------------------------------------------

#if defined(MH_BUS_RS485_ON)
	#define RS_485_INIT()		(RS_485_DDR |= (1 << RS_485_PIN))
	#define RS_485_IN			(RS_485_PORT &= ~(1 << RS_485_PIN))
	#define RS_485_OUT			(RS_485_PORT |= (1 << RS_485_PIN))
	#define RS_485_TIME_OUT		10
#endif

//-------------------------------------------------------------------------
//						Вспомогательные переменные
//------------------------------------------------------------------------

volatile BYTE eeprom_add EEMEM;		// Адрес слейв устройства
volatile BYTE mh_data[8] = {0};		// Массив полученных данных из пакета
	
#define MH_BUS_ADD		mh_data[0]		// Аврес ведомого устройства
#define MH_BUS_COM		mh_data[1]		// Команда для ведомого устройства
#define MH_BUS_REG		mh_data[2]		// Номер регистра
#define MH_BUS_BYTE_1	mh_data[3]		// Первый байт данных
#define MH_BUS_BYTE_2	mh_data[4]		// Второй байт данных
#define MH_BUS_BYTE_3	mh_data[5]		// Третий байт данных
#define MH_BUS_BYTE_4	mh_data[6]		// Четвертый байт данных

//-------------------------------------------------------------------------
//	Функция инициализации MH-BUS
//
//-------------------------------------------------------------------------

void mhbus_init(void)
{	
	usart_init(MH_BUS_USART_BOD);

//--------------------------------------------------------
#if defined(MH_BUS_RS485_ON)
	RS_485_INIT();
	RS_485_IN;
#endif
}
//--------------------------------------------------------

//-------------------------------------------------------------------------
//	Функция проверки контрольной суммы
//
//	Принимает аргументы:
//
//		BYTE *data указатель на первый элемент массива данных для проверки
//
//		Возвращает TRUE если контрольная сумма совпала или FALSE если  
//      контрольная сумма не совпала.
//-------------------------------------------------------------------------

BYTE mhbus_sum(BYTE *data)
{
	WORD compare = 0;
	WORD crc = 0;
	BYTE i = 0;
	
	while (i < 7)
		{
			compare += *data;
			data++;
			i++;
		}
	
	crc = *data;
	crc = (crc << 8);
	data++;
	crc |= *data;

	if(crc != compare) return FALSE;
	return TRUE;
}

//-------------------------------------------------------------------------
//	Функция проверки пакета
//
//	Принимает аргументы:
//
//		BYTE *data указатель на первый элемент массива полученных данных
//
//	Возвращаемые параметры.
//
//		OK				Пакет целый, данные в норме
//		STOP_FAIL		Битый стоп байт
//		START_FAIL		Битый старт байт
//		CON_SUM_FAIL	Несовпадение контрольной суммы
//		COM_FAIL		Неприемлимая команда
//
//-------------------------------------------------------------------------

BYTE mhbus_test(BYTE *arr)
{
	BYTE arr_data[9];
	UBYTE i = 0;
	
	if(*arr != MH_BUS_START_BYTE) return MH_BUS_START_FAIL;
	arr++;
	
	for (i=0; i<9; i++)
		{
			arr_data[i] = *arr;
			arr++;
		}
	
	if(!(mhbus_sum(arr_data))) return MH_BUS_CON_SUM_FAIL;
	if(arr_data[1] < 0x21) return MH_BUS_COM_FAIL;
	if(*arr != MH_BUS_STOP_BYTE) return MH_BUS_STOP_FAIL;
	
	return MH_BUS_OK;
}

//-------------------------------------------------------------------------
//	Функция чтения данных из порта.
//
//	Приниает аргумент WORD timeout период времени ожидания ответа в мс.
//  Возвращает FALSE или ошибку если данные не пришли или пришли с ошибкой.
//  Возвращает OK если данные пришли и полсле проверки записаны в передавакмый массив
//
//-------------------------------------------------------------------------

#if defined(MH_BUS_SLAVE)	// Если Слейв
	BYTE mhbus_read(BYTE test_add, BYTE timeout)
#endif

#if defined(MH_BUS_MASTER)	// Если Мастер
	BYTE mhbus_read(WORD timeout)
#endif
{
	
	BYTE temp[11];
	BYTE answer = FALSE;

	while ((!uart_flag) && timeout)
		{
			timeout = timeout - 1;
			_delay_ms(1);
		}
	
	_delay_ms(50);
	
	answer = usart_data();
	
	if(!answer) 
		{
			return MH_BUS_MOD_FAIL;
		}
	
	answer = usart_str_in(temp);
	
	if(answer != 11) return MH_BUS_FAIL_DATA;
	
	answer = mhbus_test(temp);
	
	if(answer != MH_BUS_OK)
		{
			return answer;
		}

//--------------------------------------------------------
#if defined(MH_BUS_SLAVE)	// Если Слейв
	if(!((temp[1] == test_add) | (temp[1] == MH_BUS_ALL_ADD)))
		{
			return FALSE;
		}
#endif
//--------------------------------------------------------

	for(BYTE i=0; i<8; i++)
		{
			mh_data[i] = temp[(i+1)];
		}
	mh_data[7] = 0x00;
	
	return MH_BUS_OK;
}

//-------------------------------------------------------------------------
//	Функция передачи данных в порт.
//
//	Приниает аргументы.
//
//		BYTE com - полученная команда
//		BYTE reg - полученный регистр
//		BYTE *str - Данные необходимые для перелачи.
//					Если данные передовать не надо, то можно записать 
//					в массив все что угодно.
//-------------------------------------------------------------------------

//--------------------------------------------------------
#if defined(MH_BUS_SLAVE)	// Если Слейв
void mhbus_write(BYTE com, BYTE reg, BYTE *str)
{
	BYTE test_add = eeprom_read_byte(&eeprom_add);
#endif
#if defined(MH_BUS_MASTER)	// Если Мастер
void mhbus_write(BYTE add, BYTE com, BYTE reg, BYTE *str)
{
#endif
//-------------------------------------------------------
	
	BYTE str_out[11];
	WORD crc = 0;
	
	str_out[0] = 0xAA;
	str_out[10] = 0x55;
	
//--------------------------------------------------------
#if defined(MH_BUS_SLAVE)	// Если Слейв
	str_out[1] = test_add;
#endif
#if defined(MH_BUS_MASTER)	// Если Мастер
	str_out[1] = add;
#endif
//-------------------------------------------------------
	str_out[2] = com;
	str_out[3] = reg;
	
	for(BYTE i=4; i<8; i++)
		{
			str_out[i] = *str;
			str++;
		}
	
	for(BYTE i=1; i<8; i++)
		{
			crc += str_out[i];
		}
	
	str_out[8] = (BYTE)(crc >> 8);
	str_out[9] = (BYTE)(crc & 0x00FF);

//--------------------------------------------------------
#if defined(MH_BUS_RS485_ON)		
	RS_485_OUT;
	_delay_ms(RS_485_TIME_OUT);
#endif
//--------------------------------------------------------

	usart_mhbus_out(str_out);

//--------------------------------------------------------
#if defined(MH_BUS_RS485_ON)
	_delay_ms(RS_485_TIME_OUT);	
	RS_485_IN;
#endif
//--------------------------------------------------------

}

#if defined(MH_BUS_MASTER)	// Если Мастер
//-------------------------------------------------------------------------
//	Функция проверки ID переданного от слева после замены адреса.
//
//	Приниает аргумент ID слейва.
//
//  Возвращает TRUE если ID полученный от слейва совподает с переданным функции.
//  Возвращает FALSE если ID полученный от слейва не совподает с переданным функции.
//-------------------------------------------------------------------------

BYTE mhbus_id(UWORD id)
{
	UWORD id_slave = 0;
	
	id_slave = (((id_slave | MH_BUS_BYTE_1) << 8) | MH_BUS_BYTE_1);
	
	if(id_slave == id) return TRUE;
	
	return FALSE;
}
#endif

// Функции только для режима Слейв

#if defined(MH_BUS_SLAVE)

//-------------------------------------------------------------------------
//	Функция установки адреса слейва.
//
//	Приниает аргументы.
//
//		BYTE add - полученная команда
//		
//-------------------------------------------------------------------------

BYTE mhbus_wr_add(BYTE add)
	{
		if((add < 0) | (add > 0x34))
		{
			return MH_BUS_ADD_OVF;
		}

		eeprom_write_byte(&eeprom_add, add);
		
		return MH_BUS_OK;
	}

//-------------------------------------------------------------------------
//	Функция расчета и проверки ID полученного в первых двух байтах
//
//	Возвращает TRUE если ID совпал
//	Возвращает FALSE если ID Не совпал
//
//-------------------------------------------------------------------------

BYTE mhbus_id(void)
{
	UWORD test_id = 0;
	test_id = (((test_id | MH_BUS_BYTE_1) << 8) | MH_BUS_BYTE_2);
	
	if(test_id == MH_BUS_SLAVE_ID)
	{
		return TRUE;
	}
	return FALSE;
}

//-------------------------------------------------------------------------
//	Функция чтения адреса.
//
//	Возвращяет текущий адрес устройства
//
//-------------------------------------------------------------------------

	BYTE mhbus_rd_add(void)
	{
		return eeprom_read_byte(&eeprom_add);
	}
	
#endif

#endif /* MHBUS_SLAVE_H_ */