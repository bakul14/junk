
//-------------------------------------------------< Библиотека для работы с кольцевым буфером >----------------------------------------------------
//-------------------------------------------------<                                           >----------------------------------------------------
//-------------------------------------------------< Кузнецов Алексей 2015 http://www.avrki.ru >----------------------------------------------------

#ifndef CICLE_BUFFER_H_
#define CICLE_BUFFER_H_

//-------------------------------------------------------------------------
//				Размер буфера обязательно равен степени двойки!
//				0, 1, 2, 4, 8, 16, 32, 64, 128, 256
//				По умолчанию размер буфера равен 128 байтам
//-------------------------------------------------------------------------

#define BUFFER_SIZE 128U											
#define BUFFER_MASK (BUFFER_SIZE-1)
#define BUFFER_TIME 15

//-------------------------------------------------------------------------
//						Объявление служебных переменных
//-------------------------------------------------------------------------

volatile BYTE IndexIN, IndexOUT;
volatile BYTE buffer[BUFFER_SIZE];
volatile BYTE uart_flag = 0;
volatile BYTE uart_old = 0;

//-------------------------------------------------------------------------
//							Подключаемые библиотеки
//-------------------------------------------------------------------------

#include <avr/io.h>
#include <avr/interrupt.h>
#include <axlib/type_var.h>
#include <axlib/usart.h>


//-------------------------------------------------------------------------
//					Функция прерывания USART при получении данных
//-------------------------------------------------------------------------

#if defined(UCSR0A)
ISR(USART_RX_vect)
{
	uart_old = UDR0;
#else
ISR(USART_RXC_vect)
{
	uart_old = UDR;
#endif

	uart_flag = 1;
	InBuffer(uart_old);
}

//-------------------------------------------------------------------------
//						Функция очистки буфера
//-------------------------------------------------------------------------

void ClearBuffer(void)
{
	cli();
	IndexIN = 0;
	IndexOUT = 0;
	sei();
}

//-------------------------------------------------------------------------
//			Функция возвращает количество непрочитанных байт в буфере
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//	Возвращаемые данные функцией:
//
//		BYTE - Возвращает число равное количеству байт в буфере 
//					  прочитанные из порта.
//	
//-------------------------------------------------------------------------

BYTE IndexNumber(void)
{
	if (IndexIN >= IndexOUT)
	{
		return (IndexIN - IndexOUT);
	}
	else
	{
		return ((BUFFER_SIZE - IndexOUT) + IndexIN);
	}
}

//-------------------------------------------------------------------------
//					Функция загрузки байта данных в буфер
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//	Принимает аргументы:
//
//		BYTE value - Передает функции байт, который необходимо
//							загрузить в буфер. Увеличение счетчика 
//							адреса происходит автоматически.
//
//	Возвращаемые значения:
//
//		BYTE - Функция возвращает коды выполнения операции.
//					  Коды: BUFFER_OK - Операция выполнена успешно
//							BUFFER_OVERFLOW - Переполнение буфера
//	
//-------------------------------------------------------------------------

void InBuffer(BYTE val)
{
	IndexIN++;
	IndexIN &= BUFFER_MASK;
	buffer[IndexIN] = val;
}

//-------------------------------------------------------------------------
//					Функция выгрузки строки данных из буфера
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//	Принимает аргументы:
//
//		BYTE *str - Передает функции указатель на адрес первого элемента
//						   массива в который необходимо записать строку из буфера.
//
//		BYTE lenght - Передает фугкции длинну принимаемой строки в байтах.
//
//	После вызова данной функции в массиве будет находится строка прочитанная из
//	буфера.
//
//-------------------------------------------------------------------------

BYTE OutBufferStr(BYTE *str, BYTE lenght)
{
	for(BYTE i=0; i<lenght; i++)
	{
		IndexOUT++;
		IndexOUT &= BUFFER_MASK;
		*str = buffer[IndexOUT];
		str++;
	}
	uart_flag = 0;
	
	return lenght;
}

//-------------------------------------------------------------------------
//				Функция возвращает количество байт не прочитанных данных
//				Если нанных нет, то возвращается 0
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//	Возвращаемые значения:
//
//		BYTE - Функция возвращает коды выполнения операции.
//					  Коды: 0				- Буфер пустой
//							Количество байт - В буфере присутствуют не прочитанные данные
//
//-------------------------------------------------------------------------

BYTE GetData(void)
{
	if(IndexIN != IndexOUT)
	{
		return IndexNumber();
	}
	return 0;
}

//-------------------------------------------------------------------------	


#endif /* CICLE_BUFFER_H_ */